<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>MIME</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>MIME</h1><br/><p>TITLE: MIME Notes for “Email Content Analysis”</p><p>PURPOSE: Understand how MIME structure reveals what an email *really* contains (text, HTML, images, attachments, signatures). Use this to spot phishing, weaponized files, and deception.</p><p></p><p>------------------------------------------------------------<ol><li>What is MIME?</li></ol></p><p>------------------------------------------------------------</p><p></p><p>MIME, which stands for Multipurpose Internet Mail Extensions, is the standard that allows email to go beyond simple plain text messages. In the early days, email could only handle basic ASCII text, which meant no attachments, no HTML formatting, and no images. MIME solved this by introducing a system of headers and boundaries that break an email into different parts, each with its own type and encoding. For example, one part of the email might be plain text, another might be an HTML version with colors and links, and another part could be a PDF or Word document attachment. Each part is described with headers like “Content-Type” (what the data is), “Content-Transfer-Encoding” (how the data is packed for transport, such as base64 or quoted-printable), and “Content-Disposition” (whether it should be shown inline or offered as a download). These rules let email clients rebuild the message in a readable way for the user. For analysts, MIME is important because attackers often abuse these structures—sending attachments that pretend to be safe files, hiding links inside HTML bodies, or disguising harmful executables with misleading names. By carefully examining the MIME structure of a suspicious email, you can see the true types of content, how they are encoded, and whether there are signs of trickery, like a .pdf file that is actually an executable. In short, MIME is the “packaging system” of email, and understanding it gives you the ability to peel back the wrapping to see what’s really inside.</p><p></p><p>------------------------------------------------------------<ol><li>MIME Overview (What is MIME?)</li></ol></p><p>------------------------------------------------------------</p><p>Multipurpose Internet Mail Extensions (MIME) is the standard that lets email carry more than plain ASCII text. Before MIME, email infrastructure assumed messages were simple text, which made sending images, PDFs, or non-English characters unreliable. MIME extends the message format with descriptive headers that label what each part of the message is (its media type) and how it’s encoded for safe transport. This turns email into a flexible container that can hold text, HTML, images, audio/video, and arbitrary file attachments—while remaining backward compatible so older clients can still read the basic text.</p><p></p><p>------------------------------------------------------------<ol><li>MIME Headers (How MIME describes content)</li></ol></p><p>------------------------------------------------------------</p><p>MIME relies on extra headers to tell the receiving client how to interpret each piece of the message. The most important are Content-Type, which names the media type (for example, text/plain, text/html, image/jpeg, application/pdf) and may include parameters such as charset=UTF-8 for text; Content-Transfer-Encoding, which indicates how binary or extended characters were transformed into safe text for transport (commonly Base64 or quoted-printable); and Content-Disposition, which suggests whether a part should display inline or as an attachment and can include a filename. Together, these headers provide a machine-readable recipe so any mail client can reconstruct and present the content correctly.</p><p></p><p>------------------------------------------------------------<ol><li>MIME Multipart Messages (How one email holds many parts)</li></ol></p><p>------------------------------------------------------------</p><p>MIME introduces “multipart” containers that let a single email include several distinct parts separated by a unique boundary string. For example, multipart/alternative commonly carries two versions of the same body—plain text and HTML—so the client can choose the best version it supports. multipart/mixed allows a text body plus attachments like PDFs or images, while multipart/related bundles an HTML body with its inline images or CSS resources. The enclosing multipart section declares a boundary parameter, and each subsequent part is delimited by that boundary, enabling robust packaging of complex messages.</p><p></p><p>------------------------------------------------------------<ol><li>MIME Encoding (Moving binary through a text-only system)</li></ol></p><p>------------------------------------------------------------</p><p>Because email plumbing historically expects 7-bit text, MIME uses encodings to safely tunnel binary data and extended character sets. Base64 is the workhorse: it converts arbitrary bytes into ASCII characters at the cost of roughly 33% size growth, but with excellent reliability. Quoted-printable is optimized for mostly-text content with occasional non-ASCII characters, representing only the out-of-range bytes as “=XX” hex escapes to keep size lower. On receipt, the client reverses the encoding to restore the exact original bytes before display or saving.</p><p></p><p>------------------------------------------------------------<ol><li>MIME and Attachments (How files ride along)</li></ol></p><p>------------------------------------------------------------</p><p>Attachments are simply additional MIME parts, typically within a multipart/mixed container. Each attachment has its own headers, such as Content-Type: application/pdf; name=&quot;report.pdf&quot;, Content-Transfer-Encoding: base64, and Content-Disposition: attachment; filename=&quot;report.pdf&quot;. These tell the client what the file is, how to decode it, and whether to offer it for download or display inline. Inline images in rich emails are often provided as related parts referenced by the HTML body using content IDs (cid:), allowing the message to render images without external network fetches.</p><p></p><p>------------------------------------------------------------<ol><li>Practical Example (What happens in a real message)</li></ol></p><p>------------------------------------------------------------</p><p>Imagine sending “Here is the photo we discussed” plus a picture. The outer message declares multipart/mixed with a boundary. The first part is the human-readable body: Content-Type: text/plain; charset=UTF-8 with your sentence in UTF-8. The second part is the photo: Content-Type: image/jpeg; name=&quot;meeting.jpg&quot;, Content-Transfer-Encoding: base64, and Content-Disposition: attachment; filename=&quot;meeting.jpg&quot;, followed by the Base64 data. A modern client reads the headers, displays the text, decodes the image back to its original bytes, and presents it as an attachment or inline preview—demonstrating how MIME carries rich content reliably over legacy-friendly email rails.</p><p></p><p></p><p><ul><li>MIME = Multipurpose Internet Mail Extensions.</li><li>Extends basic RFC 5322 email so we can send:</li></ul></p><p>  – Non-ASCII text (e.g., UTF-8) </p><p>  – Rich HTML bodies</p><p>  – Multiple “parts” (e.g., text + HTML + attachments)</p><p>  – Binary files (PDFs, DOCX, ZIPs, images)<ul><li>Core building blocks are extra headers in the body section:</li></ul></p><p>  – MIME-Version: usually “1.0”</p><p>  – Content-Type: the media type of a part (e.g., text/plain, text/html, image/png, application/pdf, multipart/…)</p><p>  – Content-Transfer-Encoding: how the bytes are represented for transport (7bit, quoted-printable, base64, 8bit, binary)</p><p>  – Content-Disposition: how the part should be presented (inline vs attachment) + filename</p><p>  – Content-ID: identifier for inline resources referenced by HTML with cid: links</p><p></p><p>Memory aid:<ul><li>“Type” = what it is. “Encoding” = how it’s packed. “Disposition” = how to display/save it.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>High-value MIME types for analysts</li></ol></p><p>------------------------------------------------------------<ul><li>text/plain – Plain text body (often the “safe” alternative)</li><li>text/html – Rich body; can contain links, forms, obfuscated JS-like tricks (data URLs, meta refresh)</li><li>multipart/alternative – Parallel versions of the same message (plain text and HTML). Order matters: best/last is usually HTML.</li><li>multipart/mixed – A body with attachments.</li><li>multipart/related – HTML body + inline images/assets referenced via cid:Content-ID.</li><li>multipart/signed / multipart/encrypted – S/MIME signing and encryption wrappers.</li><li>application/pdf – PDFs; may contain embedded links/attachments (PDF/JavaScript features).</li><li>application/vnd.ms-word.document.macroEnabled.12 (.docm) – Macro-enabled Word.</li><li>application/vnd.ms-excel.sheet.macroEnabled.12 (.xlsm) – Macro-enabled Excel.</li><li>application/zip, application/x-7z-compressed – Compressed archives (often “payload containers”).</li><li>application/octet-stream – Generic “raw bytes” (warning: often used to hide true type).</li><li>application/pkcs7-signature (.p7s), application/pkcs7-mime (.p7m) – S/MIME signature/encrypted content.</li></ul></p><p></p><p>Analyst tip:<ul><li>A benign filename + risky MIME type (or vice versa) is a red flag. Always cross-check the *declared* type vs the *actual* bytes.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Multipart boundaries &amp; nesting (the “folders” inside the email)</li></ol></p><p>------------------------------------------------------------<ul><li>Multipart types use a boundary parameter to separate parts.</li><li>Think: a ZIP-like *tree* embedded in the email body.</li></ul></p><p></p><p>Example boundary header:</p><p>  Content-Type: multipart/mixed; boundary=&quot;----ABC123&quot;</p><p></p><p>The body then looks like:</p><p>  ------ABC123</p><p>  [Headers for part #1]</p><p>  [Body of part #1]</p><p>  ------ABC123</p><p>  [Headers for part #2]</p><p>  [Body of part #2]</p><p>  ------ABC123--</p><p></p><p>The final “--” after the last boundary marks the end.</p><p></p><p>Typical nesting pattern:<ul><li>multipart/mixed</li></ul></p><p>  ├─ multipart/alternative</p><p>  │   ├─ text/plain</p><p>  │   └─ text/html</p><p>  └─ application/pdf (attachment)</p><p></p><p>Analyst tip:<ul><li>If there’s both text/plain and text/html, compare them. Phishers often put benign text/plain and hide the real lure in HTML.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Content-Transfer-Encoding (how bytes are carried)</li></ol></p><p>------------------------------------------------------------<ul><li>7bit / 8bit / binary – Essentially “as-is” (ASCII vs extended).</li><li>quoted-printable (QP) – For mostly text. Non-ASCII characters are encoded like “=E2=80=93”. Long lines wrapped with “=”.</li><li>base64 – For binary data (attachments) or sometimes HTML. Looks like long A–Z, a–z, 0–9, +, /, = blocks.</li></ul></p><p></p><p>Quick checks:<ul><li>If an “attachment” is QP rather than base64, double-check—sometimes HTML “attachments” are shipped as QP.</li><li>If a “text/plain” part is base64, decode it—attackers may hide scripts or links.</li></ul></p><p></p><p>Command idea:<ul><li>base64 -d &lt; payload.b64 &gt; output.bin    # decode to raw bytes</li><li>strings output.bin | head                # quick peek at readable text</li><li>file -i output.bin                       # OS guess of true MIME type</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Content-Disposition (inline vs attachment)</li></ol></p><p>------------------------------------------------------------<ul><li>inline – meant to be displayed in the body (e.g., images in HTML).</li><li>attachment – saved/downloaded by the client.</li><li>filename= and filename*= (RFC 2231) specify the name. Attackers may:</li></ul></p><p>  – Use double extensions (invoice.pdf.exe)</p><p>  – Use right-to-left override (RLO, U+202E) to mask the true extension (e.g., “gpj.exe” displays as “exe.jpg”).</p><p>  – Use misleading names vs actual file type (e.g., “invoice.pdf” with application/octet-stream bytes that are an EXE).</p><p></p><p>Analyst tip:<ul><li>Always validate the bytes (file -i / hash + sandbox) regardless of the filename label.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Content-ID (cid:) &amp; multipart/related</li></ol></p><p>------------------------------------------------------------<ul><li>HTML references inline resources by cid:</li></ul></p><p>  &lt;img src=&quot;cid:logo123&quot;&gt; pairs with:</p><p>  Content-ID: &lt;logo123&gt;<ul><li>Phishers use real logos via cid to boost credibility. Logos don’t prove legitimacy.</li><li>Check that inline images aren’t weaponized tricks (rare) and that external references (http/https) aren’t beaconing.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>S/MIME in MIME</li></ol></p><p>------------------------------------------------------------<ul><li>Signed mail: multipart/signed or application/pkcs7-signature (smime.p7s).</li><li>Encrypted mail: application/pkcs7-mime (smime.p7m).</li><li>Signed ≠ safe. The signature validates *who sent it* and *integrity*, not that it’s benign.</li><li>If you see .p7s or .p7m, note it, export artifacts, and verify signatures with OpenSSL if needed.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Walkthrough: realistic suspicious sample (trimmed)</li></ol></p><p>------------------------------------------------------------</p><p>Raw snippet:</p><p>  MIME-Version: 1.0</p><p>  Content-Type: multipart/mixed; boundary=&quot;----MIX-9999&quot;</p><p></p><p>  ------MIX-9999</p><p>  Content-Type: multipart/alternative; boundary=&quot;--ALT-111&quot;</p><p></p><p>  ----ALT-111</p><p>  Content-Type: text/plain; charset=UTF-8</p><p>  Content-Transfer-Encoding: quoted-printable</p><p></p><p>  Please see the attached invoice.</p><p></p><p>  ----ALT-111</p><p>  Content-Type: text/html; charset=UTF-8</p><p>  Content-Transfer-Encoding: quoted-printable</p><p></p><p>  &lt;html&gt;</p><p>    &lt;body&gt;</p><p>      &lt;p&gt;Please review your &lt;b&gt;invoice&lt;/b&gt; immediately.&lt;/p&gt;</p><p>      &lt;a href=&quot;<a href="https://pay-accounts.example.co-billing.support/login">https://pay-accounts.example.co-billing.support/login</a>&quot;&gt;View&lt;/a&gt;</p><p>    &lt;/body&gt;</p><p>  &lt;/html&gt;</p><p>  ----ALT-111--</p><p></p><p>  ------MIX-9999</p><p>  Content-Type: application/octet-stream; name=&quot;Invoice_0930.pdf&quot;</p><p>  Content-Transfer-Encoding: base64</p><p>  Content-Disposition: attachment; filename=&quot;Invoice_0930.pdf&quot;</p><p></p><p>  TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p><p>  [ ... long base64 ... ]</p><p>  ------MIX-9999--</p><p></p><p>Red flags to note in case file:<ul><li>Mismatched link domain (co-billing.support) vs claimed brand.</li><li>application/octet-stream for a “.pdf” → decode + “file -i” likely reveals PE/EXE.</li><li>HTML and plain text don’t match in warning detail (HTML pushes urgent action + link).</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>How to extract &amp; inspect quickly (CLI)</li></ol></p><p>------------------------------------------------------------<ol><li>Save the raw email as message.eml (full headers + body).</li><li>Identify structure and parts:<ul><li>grep -nE &#39;^(Content-Type|Content-Disposition|Content-Transfer-Encoding|Content-ID):&#39; message.eml</li><li>awk &#39;/^Content-Type: multipart/{print}&#39; message.eml   # spot multipart roots</li></ul></li><li>Extract attachments automatically:<ul><li>ripmime -i message.eml -d ./out</li></ul></li></ol></p><p>     -i = input file, -d = output dir. Writes decoded attachments.<ul><li>munpack -q -C ./out message.eml</li></ul></p><p>     -q = quiet, -C = change to directory before saving decoded files.<ol><li>Validate the *actual* type:<ul><li>file -i ./out/*</li></ul></li><li>Decode manually (if needed):<ul><li>tail -n +&lt;line&gt; message.eml | base64 -d &gt; suspect.bin</li></ul></li><li>Hash and scan:<ul><li>sha256sum suspect.bin</li><li>Submit to sandbox or AV (per SOP).</li></ul></li><li>Inspect HTML bodies for links:<ul><li>strings out/body.html | grep -Eo &#39;(https?|data):[^&quot;&#39;\&#39;&#39; ]+&#39;</li><li>curl -I &lt;URL&gt;  (in controlled environment) to see redirects (or use a URL sandbox).</li></ul></li></ol></p><p></p><p>Optional Python one-liner to list MIME parts (for labs):</p><p>   python3 - &lt;&lt;&#39;PY&#39;</p><p>import sys,email</p><p>msg=email.message_from_file(open(&#39;message.eml&#39;,&#39;r&#39;,errors=&#39;ignore&#39;))</p><p>for i,part in enumerate(msg.walk(),1):</p><p>    print(i, part.get_content_type(), part.get(&#39;Content-Disposition&#39;), part.get_filename())</p><p>PY</p><p></p><p>------------------------------------------------------------<ol><li>Common deception patterns to document</li></ol></p><p>------------------------------------------------------------<ul><li>Declared Content-Type doesn’t match true bytes (octet-stream “masquerading”).</li><li>Double extensions or Unicode RLO to hide EXE/LNK/JS.</li><li>HTML attachment (.html/.htm) used for credential harvest (fake SSO page).</li><li>Zipped HTML/JS (“HTML smuggling”)—browser reconstructs payload client-side.</li><li>Macro-enabled Office docs (.docm/.xlsm) disguised as normal (.docx/.xlsx).</li><li>multipart/alternative where text/plain is harmless but text/html contains malicious link/forms.</li><li>multipart/related with many cid images to look authentic (logos, badges) + a single malicious CTA link.</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>What to capture in your case notes (SOC workflow)</li></ol></p><p>------------------------------------------------------------<ul><li>Full list of MIME parts in order (type, disposition, filename, size if known).</li><li>Any mismatches (declared vs actual type).</li><li>Encodings used (base64/QP) and whether decoding changed your assessment.</li><li>Final URLs extracted (with redactions per policy), redirect chain summary.</li><li>Attachment hashes (MD5/SHA256), strings of interest, and static “file -i” results.</li><li>Verdict rationale: which MIME evidence drove the decision (e.g., octet-stream EXE posing as PDF).</li></ul></p><p></p><p>------------------------------------------------------------<ol><li>Quick cheat sheet (exam memory)</li></ol></p><p>------------------------------------------------------------<ul><li>MIME-Version: 1.0 → tells you MIME is in play.</li><li>multipart/alternative → compare text/plain vs text/html.</li><li>multipart/mixed → expect attachments.</li><li>multipart/related → HTML + cid images.</li><li>base64 → decode and verify bytes; don’t trust filenames.</li><li>Content-Disposition: attachment vs inline → user-visible vs downloadable.</li><li>application/octet-stream → treat as suspicious until proven safe.</li></ul></p><p></p><p>End of MIME notes.</p></div>
</body>
</html>
